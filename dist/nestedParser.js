!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).nestedMultiParser={})}(this,(function(t){"use strict";const e={separator:"bracket",throwDuplicate:!0,assignDuplicate:!1};function s(t){return s._isDigit.test(t)}s._isDigit=new RegExp(/^\d+$/);t.NestedParser=class{constructor(t,s=e){this.data=t,this._valid=null,this._validateData={},this._errors=null,this.options=Object.assign(Object.assign({},e),s),this.isDot="dot"===this.options.separator}splitKey(t){const e=this.isDot?/\./g:/\[|\]/g,s=this.isDot?1:2;let i=-s;const r=t.replace(/\s+/g,"").split(e).filter((t=>{if(t)return i+=t.length+s,t}));if(t.length!==i)throw new Error(`key "${t}" is wrong formated`);return r}constructDepth(t,e,s,i,r,a=!1){if(t instanceof Array){const i=parseInt(e);if(t.length<i)throw new Error(`array indice from key "${r}" is upper than actual array`);return t.length===i&&t.push(s),i}if(["number","string","boolean"].includes(typeof t)){if(this.options.throwDuplicate)throw new Error(`the key "${e}" as already set`);if(this.options.assignDuplicate)return(t=i.tmp)[i.key]=i.type,this.constructDepth(t[i.key],e,s,i,r,a)}else(!(e in t)||a&&this.options.assignDuplicate)&&(t[e]=s);return e}parse(t){const e={};return Object.keys(t).forEach((i=>{const r=this.splitKey(i);let a=e;const n={tmp:a,key:r[0],type:{}};for(let t=0;t<r.length-1;t++){const e=s(r[t+1])?[]:{},o=this.constructDepth(a,r[t],e,n,i);n.tmp=a,n.key=o,n.type=e,a=a[o]}const o=t[i];this.constructDepth(a,r[r.length-1],o,n,i,!0)})),e}isValid(){this._valid=!1;try{this._validateData=this.parse(this.data),this._valid=!0}catch(t){this._errors=t}return this._valid}get validateData(){if(null===this._valid)throw new Error("You need to be call is_valid() before access validate_data");if(!1===this._valid)throw new Error("You can't get validate data");return this._validateData}get errors(){return this._errors}},Object.defineProperty(t,"__esModule",{value:!0})}));
