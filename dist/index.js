!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).nestedMultiPart={})}(this,(function(t){"use strict";const e={separator:"bracket"};function i(t,i=e){const s={},r="dot"==(null==(i=Object.assign(Object.assign({},e),i))?void 0:i.separator),o="mixed"==(null==i?void 0:i.separator)||"mixedDot"==(null==i?void 0:i.separator),n="mixedDot"==(null==i?void 0:i.separator);function a(t,e,i){return null==t?e:n&&"]"==t[t.length-1]&&!i?`${t}${e}`:r||o&&!i?`${t}.${e}`:`${t}[${e}]`}return function t(e,i){Object.keys(i).forEach((r=>{const o=i[r],n=i instanceof Array;if(o instanceof Array||o instanceof Object&&!(o instanceof Blob||o instanceof Date))t(a(e,r,n),o);else{const t=a(e,r,n);s[t]=o}}))}(void 0,t),s}const s={separator:"bracket",throwDuplicate:!0,assignDuplicate:!1};function r(t){return"number"==typeof t||r._isDigit.test(t)}r._isDigit=new RegExp(/^\d+$/);t.NestedParser=class{constructor(t,e=s){this.data=t,this._valid=null,this._validateData={},this._errors=null,this.options=Object.assign(Object.assign({},s),e),this.isDot="dot"===this.options.separator,this.isMixed="mixed"===this.options.separator,this.isMixedDot="mixedDot"===this.options.separator,this.isMixedDot&&(this.isMixed=!0)}mixedSplit(t){function e(t,e){const s=e;for(;e!=t.length&&"."!=t[e]&&"]"!=t[e]&&"["!=t[e];)e++;if(s==e)throw new Error(`invalid format key '${i}', empty key value at position ${e+o}`);return e}const i=t;let s=e(t,0);const o=s,n=[t.substring(0,s)];t=t.substring(s,t.length);let a=0,l=!1;for(;a<t.length;)if("["==t[a]){if(a++,s=e(t,a),"]"!=t[s])throw new Error(`invalid format key '${i}', not end with bracket at position ${a+o}`);if(!r(t.substring(a,s)))throw new Error(`invalid format key '${i}', list key is not a valid number at position ${a+o}`);n.push(parseInt(t.substring(a,s))),a=s+1,l=!0}else{if("]"==t[a])throw new Error(`invalid format key '${i}', not start with bracket at position ${a+o}`);if(!("."==t[a]&&!this.isMixedDot||this.isMixedDot&&("."!=t[a]&&l||"."==t[a]&&!l)))throw new Error(`invalid format key '${i}', invalid char at position ${a+o}`);this.isMixedDot&&l||a++,s=e(t,a),n.push(t.substring(a,s)),a=s,l=!1}return n}splitKey(t){if(t.replace(/\s+/g,"").length!=t.length)throw new Error(`key '${t}' is wrong formated, no space available`);if(this.isMixed)return this.mixedSplit(t);const e=this.isDot?/\./g:/\[|\]/g,i=this.isDot?1:2;let s=-i;const r=t.split(e).filter((t=>{if(t)return s+=t.length+i,t}));if(t.length!==s)throw new Error(`key "${t}" is wrong formated`);return r}constructDepth(t,e,i,s,r,o=!1){if(t instanceof Array){const s=this.isMixed?e:parseInt(e);if(t.length<s)throw new Error(`array indice '${s}' from key '${r}' is upper than actual array`);return t.length===s&&t.push(i),s}if(["number","string","boolean"].includes(typeof t)){if(this.options.throwDuplicate)throw new Error(`the key "${e}" as already set`);if(this.options.assignDuplicate)return(t=s.tmp)[s.key]=s.type,this.constructDepth(t[s.key],e,i,s,r,o)}else(!(e in t)||o&&this.options.assignDuplicate)&&(t[e]=i);return e}parse(t){const e={};return Object.keys(t).forEach((i=>{const s=this.splitKey(i);let o=e;const n={tmp:o,key:s[0],type:{}};for(let t=0;t<s.length-1;t++){const e=this.isMixed?"number"==typeof s[t+1]?[]:{}:r(s[t+1])?[]:{},a=this.constructDepth(o,s[t],e,n,i);n.tmp=o,n.key=a,n.type=e,o=o[a]}const a=t[i];this.constructDepth(o,s[s.length-1],a,n,i,!0)})),e}isValid(){this._valid=!1;try{this._validateData=this.parse(this.data),this._valid=!0}catch(t){this._errors=t}return this._valid}get validateData(){if(null===this._valid)throw new Error("You need to be call is_valid() before access validate_data");if(!1===this._valid)throw new Error("You can't get validate data");return this._validateData}get errors(){return this._errors}},t.toFormData=function(t,s=e){const r=i(t,s),o=new FormData;return Object.keys(r).forEach((t=>{let e=r[t];e instanceof Blob||(e=String(e)),o.set(t,e)})),o},t.toObject=i,Object.defineProperty(t,"__esModule",{value:!0})}));
