!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).nestedMultiPart={})}(this,(function(t){"use strict";const e={separator:"bracket"};function i(t,i=e){const s={},r="dot"==(null==(i=Object.assign(Object.assign({},e),i))?void 0:i.separator),n="mixed"==(null==i?void 0:i.separator);function o(t,e,i){return null==t?e:r||n&&!(i instanceof Array)?`${t}.${e}`:`${t}[${e}]`}return function t(e,i){Object.keys(i).forEach((r=>{const n=i[r];if(n instanceof Array||n instanceof Object&&!(n instanceof Blob||n instanceof Date))t(o(e,r,i),n);else{const t=o(e,r,i);s[t]=n}}))}(void 0,t),s}const s={separator:"bracket",throwDuplicate:!0,assignDuplicate:!1};function r(t){return r._isDigit.test(t)}r._isDigit=new RegExp(/^\d+$/);t.NestedParser=class{constructor(t,e=s){this.data=t,this._valid=null,this._validateData={},this._errors=null,this.options=Object.assign(Object.assign({},s),e),this.isDot="dot"===this.options.separator,this.isMixed="mixed"===this.options.separator}mixedSplit(t){const e=RegExp(/(^[^[\].]+)|\[(\d+)\]|(\.\w+)/);let i=0;const s=t.split(e).filter((t=>t&&t.length?t:void 0)).map(((t,e)=>(i+=t.length,e?"."!=t[0]?(i+=2,parseInt(t[0])):(1==t.length&&i--,t.substring(1,t.length)):t)));if(t.length!==i)throw new Error(`key "${t}" is wrong formated`);return s}splitKey(t){if(t.replace(/\s+/g,"").length!=t.length)throw new Error(`key '${t}' is wrong formated, no space available`);if(this.isMixed)return this.mixedSplit(t);const e=this.isDot?/\./g:/\[|\]/g,i=this.isDot?1:2;let s=-i;const r=t.split(e).filter((t=>{if(t)return s+=t.length+i,t}));if(t.length!==s)throw new Error(`key "${t}" is wrong formated`);return r}constructDepth(t,e,i,s,r,n=!1){if(t instanceof Array){const s=parseInt(e);if(t.length<s)throw new Error(`array indice '${s}' from key '${r}' is upper than actual array`);return t.length===s&&t.push(i),s}if(["number","string","boolean"].includes(typeof t)){if(this.options.throwDuplicate)throw new Error(`the key "${e}" as already set`);if(this.options.assignDuplicate)return(t=s.tmp)[s.key]=s.type,this.constructDepth(t[s.key],e,i,s,r,n)}else(!(e in t)||n&&this.options.assignDuplicate)&&(t[e]=i);return e}parse(t){const e={};return Object.keys(t).forEach((i=>{const s=this.splitKey(i);let n=e;const o={tmp:n,key:s[0],type:{}};for(let t=0;t<s.length-1;t++){const e=this.isMixed?"number"==typeof s[t+1]?[]:{}:r(s[t+1])?[]:{},a=this.constructDepth(n,s[t],e,o,i);o.tmp=n,o.key=a,o.type=e,n=n[a]}const a=t[i];this.constructDepth(n,s[s.length-1],a,o,i,!0)})),e}isValid(){this._valid=!1;try{this._validateData=this.parse(this.data),this._valid=!0}catch(t){this._errors=t}return this._valid}get validateData(){if(null===this._valid)throw new Error("You need to be call is_valid() before access validate_data");if(!1===this._valid)throw new Error("You can't get validate data");return this._validateData}get errors(){return this._errors}},t.toFormData=function(t,s=e){const r=i(t,s),n=new FormData;return Object.keys(r).forEach((t=>{let e=r[t];e instanceof Blob||(e=String(e)),n.set(t,e)})),n},t.toObject=i,Object.defineProperty(t,"__esModule",{value:!0})}));
